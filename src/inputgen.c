/**
 * @file inputgen.c
 * @author Enrico Marchionni (enrico.marchionni@studio.unibo.it)
 * @brief Implementation of an input generator of 3D objects
 * configurations of: a cube, a half sphere and a cube with a spherical
 * hole.
 * @date 2025-01
 * @details
 * This file maps the coefficients of attenuation, `f`, for each voxel
 * of an object into an output file of doubles.
 *
 * To do this the values are printed in an y independent way, where
 * `f[x][z * gl_nVoxel[Z]][y * gl_nVoxel[X] * gl_nVoxel[Z]]` is the
 * value mapped in output in each iteration.
 * This means that the program that will read the input files
 * generated by this program can read small portions of it by
 * partitioning through the y axis.
 * So the efficient unit of reading in this case is the
 * parallelepiped of size `Nx * 1 * Nz`.
 *
 * Any other kind of partition reading is not easy by the method
 * this files generates inputs.
 * An example could be the interesting case of reading a smaller
 * amount of `Nx`, `Ny` and `Nz` voxels per time, for very big input
 * files.
 * In that case this program may be rewritten differently, or the
 * reading values would be very tricky.
 * An interesting suggestion in this last case is to write small
 * cubes as units of outputs, for example y independently, starting
 * from this code.
 * In that case the unit of reading would be not be the single voxel
 * but a small cube of voxels, making it acceptable for various
 * purposes.
 *
 * The values of the attenuations are simplified to `1` for dense
 * voxels and `0` for low-density voxels.
 *
 * This file is meant for testing only.
 * @copyright
 * ```text
 * This file is part of 3D-CT-projection-cuda
 * (https://github.com/EnryMarch10/3D-CT-projection-cuda).
 * Copyright (C) 2025 Enrico Marchionni
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * ```
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "common.h"

/// Limits the number of voxels along the y axis computed per time
#define OBJ_BUFFER 100u
/// N pixels along each side of the detector
#define N_PIXEL_ALONG_SIDE (DETECTOR_SIDE_LENGTH / PIXEL_DIM)
// #define DEFAULT_WORK_SIZE 2352 // default work size, equals to floor(DETECTOR_SIDE_LENGTH / PIXEL_DIM)

#define CUBE "Cube"
#define CUBE_WITH_SPHERICAL_HOLE "CubeWithSphericalHole"
#define SPHERE "HalfSphere"

/*
 * The following global variables are defined as according to common.h header file.
 * In order to use them with the value given below, the third parameter must not be passed at launch of 'inputgen' program.
 * In case the third value is given at launch, this will be used to compute the value of gl_objectSideLength, gl_detectorSideLength,
 * gl_distanceObjectDetector and gl_distanceObjectSource; the remaining variables will keep the value given below.
 */
unsigned short gl_pixelDim = PIXEL_DIM;
unsigned short gl_angularTrajectory = ANGULAR_TRAJECTORY;
unsigned short gl_positionsAngularDistance = POSITIONS_ANGULAR_DISTANCE;
unsigned short gl_voxelXDim = VOXEL_X_DIM;
unsigned short gl_voxelYDim = VOXEL_Y_DIM;
unsigned short gl_voxelZDim = VOXEL_Z_DIM;

unsigned gl_objectSideLength = OBJECT_SIDE_LENGTH;
unsigned gl_detectorSideLength = DETECTOR_SIDE_LENGTH;
unsigned gl_distanceObjectDetector = DISTANCE_OBJECT_DETECTOR;
unsigned gl_distanceObjectSource = DISTANCE_OBJECT_SOURCE;

/*
 * The following arrays' value must be computed as follows:
 * gl_nVoxel[3] = {gl_objectSideLength / gl_voxelXDim, gl_objectSideLength / gl_voxelYDim, gl_objectSideLength / gl_voxelZDim};
 * gl_nPlanes[3] = {(gl_objectSideLength / gl_voxelXDim) + 1, (gl_objectSideLength / gl_voxelYDim) + 1, (gl_objectSideLength / gl_voxelZDim) + 1};
 */
unsigned short gl_nVoxel[3] = {N_VOXEL_X, N_VOXEL_Y, N_VOXEL_Z};
unsigned short gl_nPlanes[3] = {N_PLANES_X, N_PLANES_Y, N_PLANES_Z};

/**
 * @brief Generates a sub-section of a solid cubic object given its side length.
 *
 * @param f It is the pointer to the array on which to store the sub-section.
 * @param nOfSlices It is the number of voxel along the Y axis.
 * @param offset It is the distance (in number of voxel) of the slices to be generated from the initial slice.
 * @param sideLength It is the side length of the cubic object.
 */
void generateCubeSlice(double *f, unsigned nOfSlices, unsigned offset, unsigned sideLength)
{
    const long int innerToOuterDiff = gl_nVoxel[X] / 2 - sideLength / 2;
    const long int rightSide = innerToOuterDiff + sideLength;

    // Iterates over each voxel of the grid
    // Be careful, with GCC the OpenMP collapse doesn't work if you declare the indexes as unsigned short!!
#pragma omp parallel for collapse(3) default(none) shared(f, nOfSlices, gl_nVoxel, offset, sideLength, innerToOuterDiff, rightSide)
    for (unsigned y = 0 ; y < nOfSlices; y++) {
        for (unsigned z = 0; z < gl_nVoxel[Z]; z++) {
            for (unsigned x = 0; x < gl_nVoxel[X]; x++) {
                if (z >= innerToOuterDiff && z <= rightSide && x >= innerToOuterDiff && x <= rightSide
                        && y + offset >= innerToOuterDiff && y + offset <= gl_nVoxel[Y] - innerToOuterDiff) {
                    // Voxel position is inside the cubic object
                    // In a 3D matrix it would be: f[x][z * gl_nVoxel[Z]][y * gl_nVoxel[X] * gl_nVoxel[Z]]
                    f[x + (unsigned) z * gl_nVoxel[Z] + (unsigned) y * gl_nVoxel[X] * gl_nVoxel[Z]] = 1.0;
                } else {
                    f[x + (unsigned) z * gl_nVoxel[Z] + (unsigned) y * gl_nVoxel[X] * gl_nVoxel[Z]] = 0.0;
                }
            }
        }
    }
}

/**
 * @brief Generates a sub-section of a solid spherical object given its diameter.
 *
 * @param f It is the pointer to the array on which to store the sub-section.
 * @param nOfSlices It is the number of voxel along the Y axis.
 * @param offset It is the distance (in number of voxel) of the slices to be generated from the initial slice.
 * @param diameter It is the diameter of the sphere.
 */
void generateSphereSlice(double *f, unsigned short nOfSlices, unsigned short offset, unsigned diameter)
{
    // Iterates over each voxel of the grid
    // Be careful, with GCC the OpenMP collapse doesn't work if you declare the indexes as unsigned short!!
#pragma omp parallel for collapse(3) default(none) shared(f, nOfSlices, gl_nVoxel, offset, diameter, gl_objectSideLength, gl_voxelYDim, gl_voxelXDim, gl_voxelZDim)
    for (unsigned y = 0; y < nOfSlices; y++) {
        for (unsigned z = 0; z < gl_nVoxel[Z]; z++) {
            for (unsigned x = 0; x < gl_nVoxel[X]; x++) {
                Point temp;
                temp.y = -(double) gl_objectSideLength / 2.0 + gl_voxelYDim / 2.0 + (y + offset) * gl_voxelYDim;
                temp.x = -(double) gl_objectSideLength / 2.0 + gl_voxelXDim / 2.0 + x * gl_voxelXDim;
                temp.z = -(double) gl_objectSideLength / 2.0 + gl_voxelZDim / 2.0 + z * gl_voxelZDim;
                const double distance = sqrt(pow(temp.x, 2) + pow(temp.y, 2) + pow(temp.z, 2));
                if (distance <= diameter && x < gl_nVoxel[Z] / 2) {
                    // Voxel position is inside the sphere object
                    // In a 3D matrix it would be: f[x][z * gl_nVoxel[Z]][y * gl_nVoxel[X] * gl_nVoxel[Z]]
                    f[x + (unsigned) z * gl_nVoxel[Z] + (unsigned) y * gl_nVoxel[X] * gl_nVoxel[Z]] = 1.0;
                } else {
                    f[x + (unsigned) z * gl_nVoxel[Z] + (unsigned) y * gl_nVoxel[X] * gl_nVoxel[Z]] = 0.0;
                }
            }
        }
    }
}

/**
 * @brief Generates a sub-section of a solid cubic object with an internal spherical cavity.
 *
 * @param f It is the pointer to the array on which to store the sub-section.
 * @param nOfSlices It is the number of voxel along the Y axis.
 * @param offset It is the distance (in number of voxel) of the slices to be generated from the initial slice.
 * @param sideLength It is the side length of the cubic object.
 */
void generateCubeWithSphereSlice(double *f, unsigned short nOfSlices, unsigned short offset, const unsigned sideLength)
{
    const long int innerToOuterDiff = gl_nVoxel[X] / 2 - sideLength / 2;
    const long int rightSide = innerToOuterDiff + sideLength;
    const Point sphereCenter = {-(double) sideLength * gl_voxelXDim / 4.0, -(double) sideLength * gl_voxelYDim / 4.0, -(double) sideLength * gl_voxelZDim / 4.0};

    // Iterates over each voxel of the grid
    // Be careful, with GCC the OpenMP collapse doesn't work if you declare the indexes as unsigned short!!
#pragma omp parallel for collapse(3) default(none) shared(f, nOfSlices, offset, sideLength, gl_nVoxel, innerToOuterDiff, rightSide, sphereCenter, gl_objectSideLength, gl_voxelYDim, gl_voxelXDim, gl_voxelZDim)
    for (unsigned y = 0 ; y < nOfSlices; y++) {
        for (unsigned z = 0; z < gl_nVoxel[Z]; z++) {
            for (unsigned x = 0; x < gl_nVoxel[X]; x++) {
                f[x + (unsigned) z * gl_nVoxel[Z] + (unsigned) y * gl_nVoxel[X] * gl_nVoxel[Z]] = 0.0;
                if (z >= innerToOuterDiff && z <= rightSide && x >= innerToOuterDiff && x <= rightSide
                        && y + offset >= innerToOuterDiff && y + offset <= gl_nVoxel[Y] - innerToOuterDiff) {
                    // Voxel position is inside the cubic object
                    Point temp;
                    temp.y = -(double) gl_objectSideLength / 2.0 + gl_voxelYDim / 2.0 + (y + offset) * gl_voxelYDim;
                    temp.x = -(double) gl_objectSideLength / 2.0 + gl_voxelXDim / 2.0 + x * gl_voxelXDim;
                    temp.z = -(double) gl_objectSideLength / 2.0 + gl_voxelZDim / 2.0 + z * gl_voxelZDim;
                    const double distance = sqrt(pow(temp.x - sphereCenter.x, 2) + pow(temp.y - sphereCenter.y, 2) + pow(temp.z - sphereCenter.z, 2));

                    if (distance > sideLength * gl_voxelXDim / 6.0) {
                        // Voxel position is outside the spherical cavity
                        // In a 3D matrix it would be: f[x][z * gl_nVoxel[Z]][y * gl_nVoxel[X] * gl_nVoxel[Z]]
                        f[x + (unsigned) z * gl_nVoxel[Z] + (unsigned) y * gl_nVoxel[X] * gl_nVoxel[Z]] = 1.0;
                    }
                }
            }
        }
    }
}

static void printSizeMaxGB(const char *name, size_t size) {
    if (size > 1024) {
        double approximation = size / 1024.0;
        if (approximation > 1024.0) {
            approximation = approximation / 1024.0;
            if (approximation > 1024.0) {
                approximation = approximation / 1024.0;
                printf("%s %.2lf GB\n", name, approximation);
            } else {
                printf("%s %.1lf MB\n", name, approximation);
            }
        } else {
            printf("%s %lf KB\n", name, approximation);
        }
    } else {
        printf("%s %lu B\n", name, size);
    }
}

/**
 * @brief Stores the environment values used to compute the voxel grid into the specified binary file.
 *
 * @param filePointer The file pointer to store the values in.
 * @return The number of Bytes written in output, -1 if error occurred.
 */
int writeSetUp(FILE *const filePointer)
{
    unsigned short setUp0[] = {
        gl_pixelDim,
        gl_angularTrajectory,
        gl_positionsAngularDistance,
        gl_voxelXDim,
        gl_voxelYDim,
        gl_voxelZDim,
        gl_nVoxel[X],
        gl_nVoxel[Y],
        gl_nVoxel[Z],
        gl_nPlanes[X],
        gl_nPlanes[Y],
        gl_nPlanes[Z]
    };
    if (!fwrite(setUp0, sizeof(unsigned short), sizeof(setUp0) / sizeof(unsigned short), filePointer)) {
        return -1;
    }

    unsigned setUp1[] = {
        gl_objectSideLength,
        gl_detectorSideLength,
        gl_distanceObjectDetector,
        gl_distanceObjectSource,
    };
    if (!fwrite(setUp1, sizeof(unsigned), sizeof(setUp1) / sizeof(unsigned), filePointer)) {
        return -1;
    }

#ifdef PRINT_VARIABLES
    printf("Variables WRITE:\n");
    printf("- unsigned short:\n");
    printf("    gl_pixelDim = %hu\n", gl_pixelDim);
    printf("    gl_angularTrajectory = %hu\n", gl_angularTrajectory);
    printf("    gl_positionsAngularDistance = %hu\n", gl_positionsAngularDistance);
    printf("    gl_voxelXDim = %hu\n", gl_voxelXDim);
    printf("    gl_voxelYDim = %hu\n", gl_voxelYDim);
    printf("    gl_voxelZDim = %hu\n", gl_voxelZDim);
    printf("    gl_nVoxel[X] = %hu\n", gl_nVoxel[X]);
    printf("    gl_nVoxel[Y] = %hu\n", gl_nVoxel[Y]);
    printf("    gl_nVoxel[Z] = %hu\n", gl_nVoxel[Z]);
    printf("    gl_nPlanes[X] = %hu\n", gl_nPlanes[X]);
    printf("    gl_nPlanes[Y] = %hu\n", gl_nPlanes[Y]);
    printf("    gl_nPlanes[Z] = %hu\n", gl_nPlanes[Z]);
    printf("- unsigned:\n");
    printf("    gl_objectSideLength = %u\n", gl_objectSideLength);
    printf("    gl_detectorSideLength = %u\n", gl_detectorSideLength);
    printf("    gl_distanceObjectDetector = %u\n", gl_distanceObjectDetector);
    printf("    gl_distanceObjectSource = %u\n", gl_distanceObjectSource);
#endif

    return sizeof(setUp0) + sizeof(setUp1);
}

int main(int argc, char *argv[])
{
    int objectType = 0; // represents the object type chosen
    // int n = DEFAULT_WORK_SIZE; // number of voxels along the detector's

    if (argc > 4 || argc < 2) {
        fprintf(stderr,
            "Usage:\n%s DEST [OBJECT] [PIXELS]\nWhere:\n"
            " - DEST: is the output file name.\n"
            " - [OBJECT]: can be: '%s' (default), '%s' or '%s'.\n"
            " - [PIXELS]: is the number of pixels per side of the detector, every other parameter is set based to its"
            " value, if no value is given, default values are used.\n",
            argv[0],
            CUBE,
            SPHERE,
            CUBE_WITH_SPHERICAL_HOLE);
        return EXIT_FAILURE;
    }
    char *fileName = argv[1];
    if (argc > 2) {
        if (strcmp(argv[2], CUBE_WITH_SPHERICAL_HOLE) == 0) {
            objectType = 1;
        } else if (strcmp(argv[2], SPHERE) == 0) {
            objectType = 2;
        } else if (strcmp(argv[2], CUBE) != 0) {
            fprintf(stderr,
                "Usage:\n%s DEST [OBJECT] [PIXELS]\nWhere:\n"
                " - [OBJECT]: can be: '%s' (default), '%s' or '%s', nothing else is accepted.\n",
                argv[0],
                CUBE,
                SPHERE,
                CUBE_WITH_SPHERICAL_HOLE);
            return EXIT_FAILURE;
        }
        if (argc > 3) {
            const int n = atoi(argv[3]);
            gl_objectSideLength = n * gl_voxelXDim * ((double) OBJECT_SIDE_LENGTH / (VOXEL_X_DIM * N_PIXEL_ALONG_SIDE));
            gl_detectorSideLength = n * gl_pixelDim;
            gl_distanceObjectDetector = 1.5 * gl_objectSideLength;
            gl_distanceObjectSource = 6 * gl_objectSideLength;
            gl_nVoxel[X] = gl_objectSideLength / gl_voxelXDim;
            gl_nVoxel[Y] = gl_objectSideLength / gl_voxelYDim;
            gl_nVoxel[Z] = gl_objectSideLength / gl_voxelZDim;
            gl_nPlanes[X] = gl_nVoxel[X] + 1;
            gl_nPlanes[Y] = gl_nVoxel[Y] + 1;
            gl_nPlanes[Z] = gl_nVoxel[Z] + 1;
        }
    }

    // Array containing the coefficients of each voxel
    double *f = (double *) malloc(sizeof(double) * gl_nVoxel[X] * OBJ_BUFFER * gl_nVoxel[Z]);

    FILE *filePointer = fopen(fileName, "wb");
    if (!filePointer) {
        fprintf(stderr, "Unable to open file '%s' in write binary mode!\n", fileName);
        return EXIT_FAILURE;
    }

    // Write the voxel grid dimensions on file
    const size_t headerLength = writeSetUp(filePointer);
    if (headerLength < 0) {
        fprintf(stderr, "Unable to write on file '%s'!\n", fileName);
        return EXIT_FAILURE;
    }

    // Iterates over each object subsection which size is limited along the y coordinate by OBJ_BUFFER
    for (unsigned short slice = 0; slice < gl_nVoxel[Y]; slice += OBJ_BUFFER) {
        unsigned short nOfSlices;

        if (gl_nVoxel[Y] - slice < OBJ_BUFFER) {
            nOfSlices = gl_nVoxel[Y] - slice;
        } else {
            nOfSlices = OBJ_BUFFER;
        }

        // Generates object subsection
        switch (objectType) {
            case 1:
                generateCubeWithSphereSlice(f, nOfSlices, slice, gl_nVoxel[X]);
                break;
            case 2:
                generateSphereSlice(f, nOfSlices, slice, gl_objectSideLength / 2);
                break;
            default:
                generateCubeSlice(f, nOfSlices, slice, gl_nVoxel[X]);
                break;
        }

        if (!fwrite(f, sizeof(double), (size_t) gl_nVoxel[X] * gl_nVoxel[Z] * nOfSlices, filePointer)) {
            fprintf(stderr, "Unable to write on file '%s'!\n", fileName);
            return EXIT_FAILURE;
        }
    }

    printf("Output file details:\n");
    printSizeMaxGB("    Voxel model size:", sizeof(double) * gl_nVoxel[X] * gl_nVoxel[Z] * gl_nVoxel[Y]);
    printf("    Image type: %lu bit real\n", sizeof(double) * 8);
    printf("    Image width: %d pixels\n", gl_nVoxel[X]);
    printf("    Image height: %d pixels\n", gl_nVoxel[Z]);
    printf("    Offset to first image: %lu Bytes\n", headerLength);
    printf("    Number of images: %d\n", gl_nVoxel[Y]);
    printf("    Gap between images: 0 bytes\n");

    fclose(filePointer);
    free(f);

    return EXIT_SUCCESS;
}
