\documentclass[12pt,a4paper]{report}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{times} % Selected font
\usepackage{xcolor} % Colors
\usepackage[colorlinks=true, linkcolor=blue, citecolor=blue, urlcolor=blue, pdfborder={0 0 0}]{hyperref}
\usepackage{float} % For anchor options
\usepackage{graphicx} % Images
\graphicspath{{img/}}
\newcounter{figcounter} % Initialize new counter to 0
\usepackage{setspace} % For flexible line spacing management
\usepackage[margin=1in]{geometry} % Page geom
\usepackage{lastpage} % To track the total number of pages
\usepackage{fancyhdr} % To define a custom page numbering style
\usepackage[backend=biber, style=alphabetic, sorting=ydnt]{biblatex} % To include bibliography
\addbibresource{riferimenti.bib}
\usepackage{amsmath} % Necessary for \text{} command inside maths notations
\setlength{\parskip}{0.5em} % Set global paragraph spacing
\setlength{\parindent}{0pt} % No paragraph indentation
\usepackage{enumitem} % To avoid interline between bullets and text before them
\setlist[itemize]{topsep=0pt, partopsep=0pt, parsep=0pt}
\usepackage{tikz} % To draw graphs
\usetikzlibrary{3d} % For 3D graphs

\begin{document}

\begin{spacing}{1.5}
\begin{titlepage}

\begin{center}

% marchio di ateneo
\includegraphics[width=6.5cm,height=4.7cm]{marchio-di-ateneo}

\vspace{4mm}

{Dipartimento di Informatica - Scienza e Ingegneria - DISI}

\vspace{2mm}

{\large{Corso di Laurea in Ingegneria e Scienze Informatiche}}

\vspace{10mm}

{\huge{\bf{IMPLEMENTAZIONE CUDA DI}}}\\
\vspace{3mm}
{\huge{\bf{UN ALGORITMO DI PROIEZIONE}}}\\
\vspace{3mm}
{\huge{\bf{TOMOGRAFICA}}}\\
\vspace{3mm}

\vspace{5mm}
{Tesi di Laurea in Ingegneria e Scienze Informatiche}

\end{center}

\vspace{10mm}

\noindent\begin{minipage}[t]{0.40\textwidth}
{\large{Relatore: \\ Prof. Moreno Marzolla}}

\vspace{3mm}

{\large{Correlatore: \\ Prof. Elena Loli Piccolomini}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.40\textwidth}\raggedleft
{\large{Presentata da: \\ Enrico Marchionni}}
\end{minipage}

\vfill

\hrule height 0.6mm

\begin{center}
{Sessione marzo 2025\\}
{Anno Accademico 2024/2025\\}
\end{center}

\end{titlepage}
\end{spacing}

\begin{abstract}
La Tomografia Computerizzata (TC) è una tecnica diagnostica che sfrutta le radiazioni ionizzanti (o raggi X) per ottenere
un'immagine tridimensionale di un'entità analizzata.
Questa tecnica si basa sulla raccolta, da parte di un rilevatore, di una matrice di dati 2D.
Tale matrice è costruita a partire da considerazioni fatte sull'attenuazione dei raggi X che, diretti da una sorgente verso il
rilevatore, passano attraverso l'oggetto di studio, vagliandolo.
Facendo ruotare la sorgente e il rilevatore, lungo una traiettoria nota, molte matrici di dati vengono in genere raccolte.
Queste matrici 2D vengono poi trasferite in un calcolatore che ha il compito di ricostruire l'entità scansionata in 3D.
Questo consente di esaminare l'oggetto ricostruito, osservandone alcune caratteristiche della sua struttura interna non note a
priori, senza doverlo a tal scopo necessariamente disassemblare.

Nonostante sfruttata principalmente in ambito medico, la teoria su cui si basa la TC, in realtà, non fu ideata per scopi medici.
Infatti tale tecnica trova applicazione in numerosi altri ambiti oltre alla medicina, tra cui vari settori industriali, la
paleontologia, l'archeologia e numerosi altri campi.

Il principio su cui si basa ha origine grazie al matematico austriaco Johann Radon, che nel 1917 dimostrò la possibilità di
ricostruire un oggetto tridimensionale mediante un numero infinito di proiezioni bidimensionali dell'oggetto stesso.
Dal punto di vista matematico, questo rappresenta un problema inverso, cioè si determinano le cause (immagine 3D) a partire dagli
effetti osservati (proiezioni 2D).

In questa analisi viene invece affrontato il problema diretto: partendo dal corpo studiato si devono perciò determinare le
proiezioni che una TC potrebbe generare.
Gli obiettivi di questo lavoro sono:
\begin{itemize}
  \item Implementare una versione CUDA di un certo algoritmo di proiezione proposto da Siddon \cite{Siddon1984} partendo da
        una sua implementazione parallela in C che sfrutta OpenMP \cite{Colletta2024}.
  \item Analizzare le prestazioni della versione CUDA per GPU e confrontarle con la versione parallela per CPU già nota.
\end{itemize}
\end{abstract}

\fancypagestyle{fancy}{\fancyfoot[C]{\thepage}}
\fancypagestyle{plain}{\fancyfoot[C]{\thepage}}
\pagestyle{fancy}
\pagenumbering{roman}
\tableofcontents
\clearpage

\fancypagestyle{fancy}{\fancyfoot[C]{\thepage\ di \pageref{LastPage}}}
\fancypagestyle{plain}{\fancyfoot[C]{\thepage\ di \pageref{LastPage}}}
\pagestyle{fancy}
\newpage
\pagenumbering{arabic}

\chapter{Introduzione}

Una proiezione è una matrice i cui valori rappresentano l'attenuazione dei raggi X che attraversano il corpo oggetto di studio.
Considerando un'immagine generata a partire dalla matrice proiezione, i colori rappresentano graficamente i vari livelli di
attenuazione: un raggio che attraversa una regione più densa del corpo subisce una maggiore attenuazione rispetto ad un
raggio che attraversa una regione meno densa.

Durante una scansione tomografica sono acquisite numerose immagini attorno all'oggetto di studio.
Nel caso più semplice, che noi analizzeremo, si possono considerare le diverse angolazioni di una traiettoria circolare.
Intuitivamente più sono le proiezioni acquisite, più la ricostruzione dell'oggetto sarà efficace.
D'altra parte, specialmente in ambito medico, ridurre l'esposizione alle radiazioni è di beneficio per l'individuo scansionato.
Questo implica che il numero di proiezioni generate è esso stesso molto variabile in base all'applicazione.

Nelle sezioni successive verrà illustrato il modello matematico che costituisce la base della computazione, mettendolo in
relazione diretta con le sue applicazioni nell'algoritmo risolutivo.
Infine, sarà esaminato il problema dal punto di vista geometrico.

\section{Il modello matematico}

Di seguito verranno discusse le nozioni matematiche fondamentali per comprendere, dal punto di vista algebrico, il calcolo
alla base della creazione delle proiezioni, vedi \cite{MoroLoli2021}.

\subsection{La legge di Lambert-Beer}

Dal punto di vista fisico, i dati di proiezione riflettono l'assorbimento dei fotoni che costituiscono i raggi X.
Il modello fisico che descrive l'assorbimento dei fotoni in termini di coefficienti di attenuazione è descritto dalla legge di
Lambert-Beer.

Il meccanismo fisico che porta all'attenuazione dell'intensità dei raggi è solitamente descritto da un singolo coefficiente di
attenuazione \(\mu = \mu(w) \ge 0\) che dipende dalla posizione lungo il percorso del raggio, indicata da \(w\).
Questi coefficienti determinano i vari \(m(w)\), cioè le intensità del raggio nella posizione indicata da \(w\).

La \textbf{legge di Lambert-Beer} per il calcolo della proiezione del coefficiente di attenuazione lungo un segmento di lunghezza
\(W\) è:
\begin{equation} \label{eq:law_lambert-beer}
  P_W\mu = - \ln{(\frac{m}{m_0})} = \int_0^W \mu(w) \, dw
\end{equation}

Dove:
\begin{itemize}
  \item \(m\) è l'intensità finale del raggio, dopo aver attraversato il materiale.
  \item \(m_0\) è l'intensità iniziale del raggio.
  \item \(\mu(w)\) è una funzione continua che descrive il coefficiente di attenuazione alla posizione \(w\) lungo il raggio.
  \item \(W\) è la lunghezza totale del percorso attraverso il materiale.
\end{itemize}

\subsection{La trasformata di Radon}

La \textbf{trasformata di Radon}, in un modello continuo, è data dall'insieme delle proiezioni acquisite lungo l'intera
traiettoria circolare.
La rappresentazione grafica di tutti i dati misurati nel caso bidimensionale è chiamata \textit{sinogramma}.

\subsection{Il caso discreto}

Nel caso discreto il corpo è diviso in volumi più piccoli, detti \textbf{voxel}, che sono elementi di dimensione molto piccola in
cui il corpo è approssimato.
Per ciascun voxel il coefficiente di attenuazione è un valore approssimato costante.

L'\autoref{eq:law_lambert-beer} nel caso discreto, per calcolare una singola proiezione, diventa:
\begin{equation} \label{eq:law_lambert-beer_discrete}
  g_i = \sum_{j=0}^N M_{i, j} f_j \quad \forall i \in 1, \dots, n_p
\end{equation}

Dove:
\begin{itemize}
  \item \(i\) è l'\(i\)-esimo raggio, degli \(n_p\) considerati per quella proiezione.
  \item \(j\) è il \(j\)-esimo voxel, degli \(N\) totali che approssimano il corpo.
  \item \(g_i\) è l'attenuazione subita dall'\(i\)-esimo raggio.
  \item \(M_{i,j}\) è una matrice di \(n_p \times N\) elementi che per ogni raggio \(i\) definisce la lunghezza della porzione
        sottesa al volume di ciascun voxel \(j\).
  \item \(f_j\) è il valore del coefficiente di attenuazione assunto nel volume interno al \(j\)-esimo voxel.
\end{itemize}

Matematicamente quindi, per il calcolo delle proiezioni, viene considerata un'approssimazione dell'oggetto analizzato, vedi
\autoref{fig:CT_cube_to_voxels}.

\begin{figure}[H]
  \centering
  \resizebox{0.8\textwidth}{!}{
    \begin{tikzpicture}[x={(0.9cm,-0.3cm)}, y={(0cm,1cm)}, z={(-0.9cm,-0.3cm)}]

    % Draw the grid on the top face
    \foreach \i in {0,...,6} {
      \draw[gray] (\i,6,0) -- (\i,6,6);
      \draw[gray] (0,6,\i) -- (6,6,\i);
    }

    % Draw the grid on the left face
    \foreach \i in {0,...,6} {
      \draw[gray] (\i,0,6) -- (\i,6,6);
      \draw[gray] (0,\i,6) -- (6,\i,6);
    }

    % Draw the grid on the right face
    \foreach \i in {0,...,6} {
      \draw[gray] (6,0,\i) -- (6,6,\i);
      \draw[gray] (6,\i,0) -- (6,\i,6);
    }

    % Outline the cube
    \draw[thick, darkgray] (0,6,0) -- (6,6,0) -- (6,6,6) -- (0,6,6) -- (0,6,0); % Top face
    \draw[thick, darkgray] (0,0,6) -- (6,0,6) -- (6,0,0); % Bottom face
    \draw[thick, darkgray] (0,6,6) -- (0,0,6); % Left vertical
    \draw[thick, darkgray] (6,6,6) -- (6,0,6); % Center vertical
    \draw[thick, darkgray] (6,6,0) -- (6,0,0); % Right vertical

    % Add axis arrows
    \draw[->] (6,0,0) -- (8,0,0) node[below right] {$x$}; % x-axis
    \draw[->] (0,6,0) -- (0,8,0) node[left] {$y$};        % y-axis
    \draw[->] (0,0,6) -- (0,0,8) node[below left] {$z$};  % z-axis

    % Label the cube sides
    \node[below left] at (3,0,6) {$N_x$};
    \node[below right] at (6,0,3) {$N_z$};
    \node[left] at (0,3,6) {$N_y$};

    \end{tikzpicture}
  }
  \caption{\label{fig:CT_cube_to_voxels} Esempio di oggetto cubico suddiviso in \(N = N_x \times N_y \times N_z\) voxel cubici.
           Nel caso generale i voxel sono dei parallelepipedi retti, nel caso più semplice possono essere dei cubi con una
           dimensione \(d = d_x = d_y = d_z\) fissata in base alle necessità.}
\end{figure}

Nel caso discreto della trasformata di Radon il numero di proiezioni dipende dal numero di posizioni considerate in cui si
effettuano le scansioni, tale numero verrà di seguito indicato con \(N_\theta\).
Ad ogni posizione la sorgente ed il rilevatore sono posti in modo da poter analizzare lo stesso oggetto da più angolazioni
diverse.

\section{Algoritmo risolutivo}

Considerando quanto già visto nel modello matematico, nel nostro caso l'algoritmo di Siddon si occupa di calcolare la matrice
\(M\), mentre il vettore \(f\) deve essere già noto in partenza.
Questi dati devono essere determinati per poter procedere con la computazione.

L'algoritmo svolge una computazione equivalente a quella descritta nell'\autoref{eq:law_lambert-beer_discrete}:
\begin{equation*}
  d = \sum_i \sum_j \sum_k l(i, j, k) \rho(i, j, k)
\end{equation*}
dove i parametri \(i\), \(j\) e \(k\) individuano un singolo voxel nello spazio tridimensionale.
In particolare, considerando una specifica configurazione di \((i, j, k)\), \(l\) rappresenta la lunghezza sottesa in quel
voxel (equivalente di \(M\)) mentre \(\rho\) rappresenta la densità del voxel (equivalente di \(f\)).

\subsection{La matrice \(M\)}

\begin{figure}[H]
  \centering
  \resizebox{0.8\textwidth}{!}{
    \begin{tikzpicture}
    % Left panel
    \begin{scope}
      \refstepcounter{figcounter} % Increment the counter
      % Grid
      \draw[step=1cm, gray] (0,0) grid (6,6);

      % Source and detector
      \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=1.5pt, label=above:Source] (source1) at (-2, 6.5) {};
      \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=1.5pt, label=below:Detector] (detector1) at (6.5, -2) {};

      % Ray line
      \draw[purple] (source1) -- (detector1);

      % Intersections
      \foreach \i in {0,...,9}{
        \fill[black] (0 + \i * 0.5,4.5 - \i * 0.5) circle (3pt);
      }
      \node at (-0.5,-0.5) {(\alph{figcounter})}; % Use the counter for the label
    \end{scope}
    % Arrow
    \node at (7.5, 3) {\Huge\textbf{$\rightarrow$}};
    % Right panel
    \begin{scope}[shift={(11,0)}]
      \refstepcounter{figcounter} % Increment the counter
      % Planes
      \foreach \y in {0,...,6} {
        \draw[gray] (-2,\y) -- (8,\y); % Horizontal lines
      }
      \foreach \x in {0,...,6} {
          \draw[gray] (\x,-2) -- (\x,8); % Vertical lines
      }

      % Source and detector
      \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=0pt, label=above:Source] (source2) at (-2, 6.5) {};
      \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=0pt, label=below:Detector] (detector2) at (6.5, -2) {};

      % Ray line
      \draw[purple] (source2) -- (detector2);

      % Intersections
      \fill[red] (-1.5,6.0) circle (3pt);
      \fill[red] (-0.5,5.0) circle (3pt);
      \foreach \i in {0,...,9}{
        \fill[black] (0 + \i * 0.5,4.5 - \i * 0.5) circle (3pt);
      }
      \fill[red] (5.0,-0.5) circle (3pt);
      \fill[red] (6.0,-1.5) circle (3pt);
      \node at (-0.5,-0.5) {(\alph{figcounter})}; % Use the counter for the label
    \end{scope}
    \end{tikzpicture}
  }
  \caption{\label{fig:CT_Siddon_grid_to_planes} Pixel (voxel nel caso 2D) considerati come rette parallele che rappresentano la
           struttura dell'oggetto considerato.
           Come si può notare alcune intersezioni tra il raggio e i piani non sono valide perché fuori dalla griglia, vedi i
           puntini rossi della figura \textit{b}.}
\end{figure}

I punti chiave dell'algoritmo, nella determinazione della matrice \(M\), possono essere così riassunti:
\begin{itemize}
  \item L'algoritmo considera, invece dei singoli voxel indipendenti, tre insiemi di piani ortogonali ed equidistanti tra loro che
        vanno a costruire la griglia di discretizzazione del corpo nello spazio, vedi \autoref{fig:CT_Siddon_grid_to_planes}.
  \item Si calcolano i punti di intersezione tra le rette, i raggi, e i piani che definiscono i voxel.
  \item Si calcola la lunghezza dei segmenti sottesi ai voxel, come la differenza tra punti di intersezione consecutivi,
        determinando così la matrice \(M\).
\end{itemize}

\subsection{Il vettore \(f\)}

Il vettore \(f\) rappresenta il coefficiente di attenuazione assunto nella regione interna al volume sotteso da ciascun voxel.
Presenta dunque un numero di elementi pari al numero di voxel in cui è suddiviso l'oggetto.

Le tre diverse configurazioni, fornite da \cite{Colletta2024}, sono state qui riutilizzate:
\begin{itemize}
  \item Un \textbf{cubo}: stabilita la lunghezza del lato del cubo che si intende rappresentare, gli elementi all'interno della
        regione cubica sono posti ad 1, altrimenti a 0.
  \item Una \textbf{semi-sfera}: stabilita la lunghezza del raggio della semisfera che si intende rappresentare, gli elementi
        all'interno della regione semisferica sono posti ad 1, altrimenti a 0.
  \item Un \textbf{cubo con cavità sferica}: stabilita la lunghezza del lato del cubo che si intende rappresentare, gli elementi
        all'interno della regione cubica, ad eccezione di quelli la cui distanza da un punto stabilito all'interno dell'oggetto
        sia inferiore ad un raggio stabilito, sono posti ad 1, altrimenti a 0.
\end{itemize}

\section{Considerazioni geometriche}

Questa sezione approfondisce le considerazioni geometriche necessarie per poter procedere con l'implementazione dell'algoritmo di
Siddon.

\subsection{Posizionamento sorgente, oggetto e rilevatore nello spazio}

\begin{figure}[H]
  \centering
  \resizebox{0.8\textwidth}{!}{
    \begin{tikzpicture}[x={(0.9cm,-0.3cm)}, y={(0cm,1cm)}, z={(-0.9cm,-0.3cm)}]
    \def\faces{6}
    \def\halfFaces{3}

    % Draw the grid on the top face
    \foreach \i in {0,0.5,...,\halfFaces} {
      \draw[gray] (\i,\halfFaces,0) -- (\i,\halfFaces,\halfFaces);
      \draw[gray] (0,\halfFaces,\i) -- (\halfFaces,\halfFaces,\i);
    }

    % Draw the grid on the left face
    \foreach \i in {0,0.5,...,\halfFaces} {
      \draw[gray] (\i,0,\halfFaces) -- (\i,\halfFaces,\halfFaces);
      \draw[gray] (0,\i,\halfFaces) -- (\halfFaces,\i,\halfFaces);
    }

    % Draw the grid on the right face
    \foreach \i in {0,0.5,...,\halfFaces} {
      \draw[gray] (\halfFaces,0,\i) -- (\halfFaces,\halfFaces,\i);
      \draw[gray] (\halfFaces,\i,0) -- (\halfFaces,\i,\halfFaces);
    }

    % Draw the grid of the detector
    \foreach \i in {0,0.5,...,9} {
      \draw[cyan] (\i,-4,0) -- (\i,-4,9);
      \draw[cyan] (0,-4,\i) -- (9,-4,\i);
    }
    \node[above right] at (3,-4,0) {Detector}; % Detector

    % Outline the cube
    \draw[thick, darkgray] (0,\halfFaces,0) -- (\halfFaces,\halfFaces,0) -- (\halfFaces,\halfFaces,\halfFaces) -- (0,\halfFaces,\halfFaces) -- (0,\halfFaces,0); % Top face
    \draw[thick, darkgray] (0,0,\halfFaces) -- (\halfFaces,0,\halfFaces) -- (\halfFaces,0,0); % Bottom face
    \draw[thick, darkgray] (0,\halfFaces,\halfFaces) -- (0,0,\halfFaces); % Left vertical
    \draw[thick, darkgray] (\halfFaces,\halfFaces,\halfFaces) -- (\halfFaces,0,\halfFaces); % Center vertical
    \draw[thick, darkgray] (\halfFaces,\halfFaces,0) -- (\halfFaces,0,0); % Right vertical

    % Add axis arrows
    \draw[->] (\halfFaces,\halfFaces/2,\halfFaces/2) -- (6,\halfFaces/2,\halfFaces/2) node[below right] {$x$}; % x-axis
    \draw[->] (\halfFaces/2,\halfFaces,\halfFaces/2) -- (\halfFaces/2,6,\halfFaces/2) node[left] {$y$};        % y-axis
    \draw[->] (\halfFaces/2,\halfFaces/2,\halfFaces) -- (\halfFaces/2,\halfFaces/2,6) node[below left] {$z$};  % z-axis, positive
    \draw[] (\halfFaces,0,\halfFaces) -- (\halfFaces,-4.9,\halfFaces);  % z-axis, negative

    % Add a point above the cube
    \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=0pt, label=right:Source] at (\halfFaces/2,5,\halfFaces/2) {}; % Source

    \end{tikzpicture}
  }
  \caption{\label{fig:CT_reference_plane} Esempio che rappresenta l'oggetto cubico già visto in \autoref{fig:CT_cube_to_voxels}
           nel sistema di riferimento cartesiano considerato nelle discussioni seguenti.}
\end{figure}

In \autoref{fig:CT_reference_plane} sono rappresentati un oggetto di forma cubica, la sorgente ed il rilevatore, tutti posti
in uno specifico sistema cartesiano, in cui il centro dell'oggetto corrisponde con l'origine degli assi.

Nel nostro caso la posizione del punto sorgente, da cui partono i raggi, e dei pixel del rilevatore, al centro di cui questi
vengono a dirigersi, ruotano in un'orbita circolare in modo da scansionare il corpo da più posizioni.

Quando la sorgente ruota in un senso nelle specifiche posizioni dell'orbita, il rilevatore ruota coerentemente nel senso opposto.

\subsection{Le sorgenti}

La sorgente è approssimata ad un punto, che indica la posizione a partire dalla quale sono diretti i raggi.
Le posizioni considerate sono più di una e sono distribuite, nell'implementazione trattata, lungo una traiettoria circolare
(o una sezione di essa) intorno all'oggetto.
Rimane da stabilire ciascuna coordinata nello spazio.

Conoscendo l'estensione angolare \(\theta\) della sezione della traiettoria considerata e la distanza angolare \(\alpha\) tra
ciascuna posizione, si è scelto l'uso delle coordinate polari, dove una posizione è individuata dalla distanza dall'origine e
dalla distanza angolare dall'asse polare.
In accordo con la \autoref{fig:CT_reference_plane}, viene considerato un sistema di coordinate polari il cui polo coincide con
il centro dell'oggetto di studio, mentre si adotta l'asse \(y\) come asse polare.
La distanza angolare è positiva in senso orario nel piano \(xy\).

La posizione della sorgente può essere individuata nel seguente modo:
\begin{equation} \label{eq:goniometric_source_polar}
  (d_s,-\theta/2 + \alpha i) \quad \text{per } i = 0, \dots, N_\theta - 1
\end{equation}

dove:
\begin{itemize}
  \item \(i\) è un indice che identifica una posizione della sorgente.
  \item \(d_s\) è la distanza sorgente-origine.
  \item \(N_\theta\) è il numero di posizioni dato dal rapporto \(N_\theta = \lfloor \theta/\alpha \rfloor + 1\).
\end{itemize}

Le coordinate cartesiane si ottengono a partire dalle coordinate polari nel seguente modo:
\begin{equation} \label{eq:gonometric_source_coordinates}
  \begin{cases}
    X_i = \cos(\frac{\pi}{2} - (-\frac{\theta}{2} + \alpha i)) d_s = \sin(-\frac{\theta}{2} + \alpha i) d_s \\
    Y_i = \sin(\frac{\pi}{2} - (-\frac{\theta}{2} + \alpha i)) d_s = \cos(-\frac{\theta}{2} + \alpha i) d_s \\
    Z_i = 0
  \end{cases} \quad \text{per } i = 0, \dots, N_\theta - 1
\end{equation}
dove sono state applicate le formule degli archi associati per seno e coseno per passare dal sistema con misurazione in senso
orario a partire dal semiasse positivo delle \(y\) al sistema tradizionale con misurazione in senso antiorario a partire dal
semiasse positivo delle \(x\).
Inoltre, \(Z_i\) è posta a \(0\) in quanto, per costruzione, la traiettoria giace sul piano \(xy\).

\subsection{L'oggetto}

Un oggetto è approssimato da un certo numero di voxel, cioè parallelepipedi retti con dimensioni uniformi l'uno con l'altro.
Le griglie che questi creano, dall'algoritmo di Siddon, sono rappresentate da un certo numero di piani paralleli tra loro.

L'equazione cartesiana di un piano nello spazio è un'equazione di primo grado in tre incognite:
\begin{equation*}
  ax + by + cz + d = 0 \quad \text{con } a, b, c, d \in \Re
\end{equation*}

Avendo in mente la \autoref{fig:CT_reference_plane}, i piani coinvolti, oltre che ad essere paralleli tra di loro, sono paralleli
anche agli assi cartesiani.
Dunque, le loro equazioni sono nella forma:
\begin{align*}
  ax + d &= 0 \quad \text{se parallelo al piano } yz \\
  by + d &= 0 \quad \text{se parallelo al piano } xz \\
  cz + d &= 0 \quad \text{se parallelo al piano } xy
\end{align*}

Dato che le distanze tra i piani paralleli sono regolari, avendo l'equazione di un piano è possibile determinare l'equazione degli
altri traslando più volte.
L'equazione degli altri piani a partire dal primo si determina nel seguente modo:
\begin{align*}
  X_{plane}(i) &= X_{plane}(1) + (i - 1) d_x \quad \forall i \in 1, \dots, N_x \\
  Y_{plane}(j) &= Y_{plane}(1) + (j - 1) d_y \quad \forall j \in 1, \dots, N_y \\
  Z_{plane}(k) &= Z_{plane}(1) + (k - 1) d_z \quad \forall k \in 1, \dots, N_z
\end{align*}

dove \(N_x\), \(N_y\) e \(N_z\) sono il numero di voxel lungo gli assi \(x\), \(y\) e \(z\), mentre \(d_x\), \(d_y\) e \(d_z\)
sono a loro volta le dimensioni di un singolo voxel lungo i tre assi cartesiani.

\subsection{I rilevatori}

Nel caso tridimensionale, il rilevatore può essere visto come una matrice di unità di misura, ossia i pixel, posizionata a una
distanza \(d_r\) dal centro del corpo in esame.

L'approccio usato per relazionare i raggi con il rilevatore è detto \textit{ray-driven}.
Per ciascun unità del rilevatore si considera l'esistenza di un unico raggio passante, diretto dalla sorgente al centro del
pixel stesso.
Secondo questo approccio, il numero \(n_p\) di raggi usati per il calcolo della proiezione coincide con il numero di pixel del
rilevatore.

Il rilevatore è sempre ortogonale all'asse che congiunge la sorgente con il centro del corpo.

Le coordinate cartesiane del centro di un'unità del rilevatore, al variare dell'angolo considerato, sono \((X', Y', Z')\),
derivate dalla posizione \((X, Y, Z)\), ricoperta nel caso in cui il rilevatore sia ortogonale all'asse \(y\).

Considerando il semiasse negativo di \(y\) come asse polare, anche questa volta con angolo positivo in senso orario, le
coordinate polari del punto sono:
\begin{equation*} %\label{eq:goniometric_detector_polar}
  (d_r, \delta)
\end{equation*}
dove \(\delta\) è l'angolo che identifica l'unità del rilevatore.

Le coordinate a seguito della traslazione saranno:
\begin{equation*}
  (d_r, \delta - \lambda)
\end{equation*}
dove \(-\lambda\) è l'angolo di traslazione.

Le coordinate di tale posizione traslata sono date da:
\begin{equation} \label{eq:goniometric_detector_coordinates}
  \begin{cases}
    X' = \cos(\frac{3\pi}{2} - (\delta - \lambda)) d_r = -\sin(\delta - \lambda) d_r \\
    Y' = \sin(\frac{3\pi}{2} - (\delta - \lambda)) d_r = -\cos(\delta - \lambda) d_r
  \end{cases}
\end{equation}
dove, in modo analogo all'\autoref{eq:gonometric_source_coordinates}, sono state applicate le formule degli archi associati per
seno e coseno per passare dal sistema con misurazione in senso orario a partire dal semi asse negativo delle \(y\) al sistema
tradizionale con misurazione in senso antiorario a partire dal semi asse positivo delle \(x\).
In questo caso \(Z\) è costante, \(Z' = Z\), in quanto, per costruzione, la traiettoria trasla sul piano \(xy\), senza influire
sulla coordinata nell'asse \(z\), quindi verrà omessa nella discussione seguente.

A partire dall'\autoref{eq:goniometric_detector_coordinates}, applicando le formule di addizione degli archi per seno e coseno si
ottiene:
\begin{equation*}
  \begin{cases}
    X' = - (\sin(\delta)\cos(-\lambda) d_r + \cos(\delta)\sin(-\lambda) d_r) \\
    Y' = - (\cos(\delta)\cos(-\lambda) d_r - \sin(\delta)\sin(-\lambda) d_r)
  \end{cases}
\end{equation*}

\begin{figure}[H]
  \centering
  \resizebox{0.4\textwidth}{!}{
    \begin{tikzpicture}
      % Define the radius of the circle trajectories
      \def\SourceRadius{3}
      \def\DetectorRadius{4}

      % Define the points
      \coordinate (S0) at ({\SourceRadius*cos(115)}, {\SourceRadius*sin(115)});
      \coordinate (D0) at ({\DetectorRadius*cos(295)}, {\DetectorRadius*sin(295)});

      % Draw the trajectories
      % \draw[thick] (0,0) circle (\SourceRadius);
      \draw[thick] (S0) arc[start angle=115,end angle=65,radius=\SourceRadius];
      \draw[thick] (D0) arc[start angle=295,end angle=245,radius=\DetectorRadius];

      % Draw the axes
      \draw[->] (-\SourceRadius-0.5,0) -- (\SourceRadius+0.5,0) node[below right] {$x$};
      \draw[->] (0,-\DetectorRadius-0.5) -- (0,\SourceRadius+0.5) node[above left] {$y$};
      \draw[->] (0.5,0.5) -- (-\SourceRadius-0.5,-\SourceRadius-0.5) node[below left] {$z$};

      % Draw lines from origin to points
      \draw[purple] (S0) -- (D0);
      \draw[dashed] (0,0) -- ({\SourceRadius*cos(65)}, {\SourceRadius*sin(65)});
      \draw[dashed] (0,0) -- ({\DetectorRadius*cos(245)}, {\DetectorRadius*sin(245)});

      % Draw the points
      \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=0pt, label=above left:Source\textsubscript{0}] at (S0) {}; % Source
      \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=0pt, label=below right:Detector\textsubscript{0}] at (D0) {}; % Detector
      % \fill[green] (S0) circle (2pt) node[above left] {$Source_0$};
      % \fill[cyan] (D0) circle (2pt) node[below right] {$Detector_0$};

      % Label theta angle
      \draw[<->] ({(\SourceRadius/2)*cos(115)}, {(\SourceRadius/2)*sin(115)}) arc[start angle=115,end angle=65,radius=1.5];
      \node[above right] at (0,1.5) {$\theta$};

      % Label delta angle
      \draw[->] (0,-2) arc[start angle=270,end angle=295,radius=2];
      \node[] at (0.5,-2.3) {$\delta$};

      % Label distance
      \node at (-1,1.4) {$d_s$};
      \node at (1.2,-1.7) {$d_r$};
    \end{tikzpicture}
  }
  \caption{\label{fig:CT_polar_coordinates} Vista goniometrica di un raggio diretto dalla prima sorgente verso il centro del pixel
           centrale nella matrice che rappresenta il rilevatore.}
\end{figure}

Osservando \autoref{fig:CT_polar_coordinates}, dalle formule trigonometriche per i triangoli rettangoli:
\begin{align*}
  d_r = -\frac{X}{\sin(\delta)} = -\frac{Y}{\cos(\delta)}
\end{align*}

sostituendo \(d_r\) e sfruttando le formule degli archi associati per seno e coseno si ottiene:
\begin{equation*}
  \begin{cases}
    X' = \cos(-\lambda) X + \sin(-\lambda) Y \\
    Y' = \cos(-\lambda) Y - \sin(-\lambda) X
  \end{cases}
\end{equation*}

Analogamente a quanto avviene con la sorgente, la posizione di una unità del rilevatore varia, ad intervalli regolari, di
un angolo \(\alpha\) su di una sezione di ampiezza regolare pari a \(\theta\).
Quindi, ricordando l'\autoref{eq:goniometric_source_polar}, si considera \(-\lambda = -\theta/2 + \alpha i\).
Le posizioni di un'unità del rilevatore possono dunque essere ottenute, a partire dalla posizione precedente, con:
\begin{equation*}
  \begin{cases}
    X'_i = \cos(-\theta/2 + \alpha i) X + \sin(-\theta/2 + \alpha i) Y \\
    Y'_i = \cos(-\theta/2 + \alpha i) Y - \sin(-\theta/2 + \alpha i) X
  \end{cases} \quad \text{per } i \in 0,\dots,N_\theta - 1
\end{equation*}

\subsection{I raggi}

Un raggio, approssimazione di radiazioni elettromagnetiche, è considerato come un segmento che, nell'implementazione usata,
collega la sorgente con il centro di un pixel del rilevatore (approccio ray-driven).

Può essere rappresentato mediante l'equazione parametrica di una retta passante per due punti \(Source = (X_1, Y_1, Z_1)\) e
\(Detector = (X_2, Y_2, Z_2)\):
\begin{align*}
  X(a) &= X_1 + a (X_2 - X_1) \\
  Y(a) &= Y_1 + a (Y_2 - Y_1) \\
  Z(a) &= Z_1 + a (Z_2 - Z_1)
\end{align*}

\setcounter{figcounter}{0}
\begin{figure}[H]
  \centering
  \resizebox{0.8\textwidth}{!}{
    \begin{tikzpicture}
    % Left-up panel
    \begin{scope}[shift={(0,9)}]
        \refstepcounter{figcounter} % Increment the counter
        % Grid
        \draw[step=1cm, gray] (0,0) grid (6,6);

        % Source and detector
        \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=1.5pt, label=above:Source] (source1) at (-2, 6.5) {};
        \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=1.5pt, label=below:Detector] (detector1) at (6.5, -2) {};

        % Ray line
        \draw[purple] (source1) -- (detector1);

        % Parameters
        \fill[black] (0,4.5) circle (3pt);
        \node[right, draw=none] at (0,4.5) {\(a_{min}\)};
        \fill[black] (4.5,0) circle (3pt);
        \node[above, draw=none] at (4.6,0.2) {\(a_{max}\)};
        \node at (-0.5,-0.5) {(\alph{figcounter})}; % Use the counter for the label
    \end{scope}
    % Right-up panel
    \begin{scope}[shift={(9,9)}]
      \refstepcounter{figcounter} % Increment the counter
      % Grid
      \draw[step=1cm, gray] (0,0) grid (6,6);

      % Source and detector
      \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=1.5pt, label=above:Source] (source2) at (1, 3.5) {};
      \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=1.5pt, label=below:Detector] (detector2) at (6.5, -2) {};

      % Ray line
      \draw[purple] (source2) -- (detector2);

      % Intersections
      \node[right, draw=none] at (1.2, 3.5) {\(a_{min} = 0\)};
      \fill[black] (4.5,0) circle (3pt);
      \node[above, draw=none] at (4.6,0.2) {\(a_{max}\)};
      \node at (-0.5,-0.5) {(\alph{figcounter})}; % Use the counter for the label
    \end{scope}
    % Left-down panel
    \begin{scope}[shift={(0,0)}]
        \refstepcounter{figcounter} % Increment the counter
        % Grid
        \draw[step=1cm, gray] (0,0) grid (6,6);

        % Source and detector
        \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=1.5pt, label=above:Source] (source3) at (-2, 6.5) {};
        \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=1.5pt, label=below:Detector] (detector3) at (3.5, 1) {};

        % Ray line
        \draw[purple] (source3) -- (detector3);

        % Intersections
        \fill[black] (0,4.5) circle (3pt);
        \node[right, draw=none] at (0,4.5) {\(a_{min}\)};
        \node[above, draw=none] at (4,1.2) {\(a_{max} = 1\)};
        \node at (-0.5,-0.5) {(\alph{figcounter})}; % Use the counter for the label
    \end{scope}
    % Right-down panel
    \begin{scope}[shift={(9,0)}]
      \refstepcounter{figcounter} % Increment the counter
      % Grid
      \draw[step=1cm, gray] (0,0) grid (6,6);

      % Source and detector
      \node[draw=none, fill=green, circle, minimum size=10pt, inner sep=1.5pt, label=above:Source] (source4) at (1, 3.5) {};
      \node[draw=none, fill=cyan, circle, minimum size=10pt, inner sep=1.5pt, label=below:Detector] (detector4) at (3.5, 1) {};

      % Ray line
      \draw[purple] (source4) -- (detector4);

      % Intersections
      \node[right, draw=none] at (1.2, 3.5) {\(a_{min} = 0\)};
      \node[above, draw=none] at (4,1.2) {\(a_{max} = 1\)};
      \node at (-0.5,-0.5) {(\alph{figcounter})}; % Use the counter for the label
    \end{scope}
    \end{tikzpicture}
  }
  \caption{\label{fig:CT_Siddon_ranges} Le quantità \(a_{min}\) e \(a_{max}\) sono quelle che definiscono i range da considerare
           per ottenere solo le intersezioni con piani effettivamente all'interno della griglia di pixel (voxel nel caso 3D).
           Si può notare che \(a_{min}\) nelle figure \textit{a} e \textit{c} sarà maggiore di 0, così come \(a_{max}\) nelle
           figure \textit{a} e \textit{b} sarà minore di 1.
           Questo permette di non considerare le intersezioni in eccesso, esterne alla griglia di partenza, risolvendo il
           problema esposto nella \autoref{fig:CT_Siddon_grid_to_planes}.}
\end{figure}

In questo modo:
\begin{itemize}
  \item Per definire un raggio basta conoscere il punto ``sorgente'' ed il punto sul ``rilevatore'' dove avviene la misurazione.
  \item È possibile rappresentare un punto appartenente alla retta del raggio attraverso un unico parametro \(a\), in particolare
        \(a = 0\) coincide con il punto \(Source\), \(a = 1\) coincide con il punto \(Detector\), per i valori di \(a\) compresi
        tra \([0, 1]\) si hanno punti interni al segmento, vedi \autoref{fig:CT_Siddon_ranges}.
\end{itemize}

Il punto di intersezione di un raggio ed un piano si ottiene risolvendo in \(a\) il sistema lineare dato dall'equazione del
piano e una componente della retta come di seguito:
\begin{equation}
  \begin{aligned}
    &\begin{cases}
      X = X_1 + a (X_2 - X_1) \\
      X = X_{planes}(1) + (i - 1) d_x
    \end{cases} \quad &\text{se } i \in 1, \dots, N_x \\
    &\begin{cases}
      Y = Y_1 + a (Y_2 - Y_1) \\
      Y = Y_{planes}(1) + (i - 1) d_y
    \end{cases} \quad &\text{se } i \in 1, \dots, N_y \\
    &\begin{cases}
      Z = Z_1 + a (Z_2 - Z_1) \\
      Z = Z_{planes}(1) + (i - 1) d_z
    \end{cases} \quad &\text{se } i \in 1, \dots, N_z
  \end{aligned} \nonumber
\end{equation}

dove sono stati indicati i sistemi utilizzati nel caso in cui il piano sia parallelo al piano \(yz\) (primo sistema), al piano
\(xz\) (secondo sistema) o al piano \(xy\) (terzo sistema).

\appendix

\chapter{Conclusioni}

\dots

\printbibliography
\thispagestyle{empty}

\end{document}
